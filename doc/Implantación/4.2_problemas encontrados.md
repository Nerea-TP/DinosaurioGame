# Problemas encontrados y soluciones

Al desarrollar la versión para Android, experimenté dificultades con el movimiento del jugador. Intenté implementar un control mediante el gesto de arrastrar el dedo en la pantalla para mover al personaje, y un salto mediante un doble toque. Sin embargo, esto generó problemas: el personaje saltaba en momentos inadecuados y, en ocasiones, el salto no se ejecutaba correctamente, lo que afectaba la movilidad del jugador.
Para solucionar estos inconvenientes, decidí implementar botones en la interfaz. Añadí un botón dedicado para saltar y flechas para el movimiento. Luego, en los scripts, configuré que en dispositivos Android los botones fueran visibles y funcionales, mientras que en ordenadores, estos botones desaparecieran y se utilizara el teclado para el control.
También experimenté problemas al implementar el sistema de autenticación en Android. En Unity, tuve que activar una opción para generar los archivos necesarios: Android manifest, mainTemplate.gradley gradleTemplate.properties.Luego, añadí el código específico para que la autenticación de Firebase funcionara en dispositivos Android. Este paso no está claramente documentado, ya que en Android Studio estos archivos están disponibles por defecto. Sin activar esta opción en Unity, el juego no funcionaría correctamente.

Al implementar el soporte multilingüe, me encontré con un desafío en la pantalla del menú. Mientras que traducir los textos del juego fue sencillo utilizando el paquete de Localization de Unity, en la pantalla del menú no había texto, sino sprites. Descubrí que para poder traducir el menú, necesitaba tener los sprites específicos para cada idioma, cosa que no tenía. Para resolver esto, busqué un programa que me permitiera crear sprites similares a los que había descargado de un blog. Para ello, utilicé GIMP, una herramienta que descargué de la Microsoft Store. Además, también tuve que adaptar el código para asegurarme de que funcionara correctamente, ya que el enfoque para los sprites era diferente al que utilicé para los textos. Esto requirió un poco más de esfuerzo para integrar todo de manera adecuada.

Luego tuve problemas con el sistema de las monedas. Al principio, el juego estaba programado para contabilizar las monedas y, si se cargaba la escena, todo volvía a empezar. Sin embargo, al implementar un sistema de puntuación, surgieron nuevos retos: cuando el dinosaurio tocaba pinchos o caía al vacío y se recargaba la escena, las monedas ya recogidas no debían aparecer nuevamente, y la puntuación debía mantenerse ya que no era un Game Over. Además, al pasar a otro nivel, al cargarse la nueva escena, la puntuación que teníamos al finalizar el nivel anterior debía ser conservada.
Este problema se debía a la recarga de escenas. Finalmente, lo solucioné utilizando PlayerPrefs para guardar las monedas que iba recogiendo. Así, si se recargaba la escena, solo se recargaban las monedas que no estaban guardadas, y al hacer Game Over, se borraba la clave para reiniciar todo. Implementé el mismo sistema para la puntuación.